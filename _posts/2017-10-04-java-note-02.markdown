---
layout: post
title: Java 笔记 2 - 类与对象
date: 2017-10-04 14:14:20 +0300
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: java.jpg # Add image post (optional)
tags: [Java]
categories: Java
---
# 类与对象
{:.no_toc}
* 目录
{:toc}

## 类和对象的理解

类是对象的蓝图。

成员变量+成员函数
 
类的构造：
* 构造函数：只有初始化对应的对象才使用。不需要返回值
* 构造代码块：给所有的对象进行初始化

对象初始化过程：Person p = new Person("amos");
* 1.先找到Baby.class文件,并加载到内存中
* 2.执行该类中Static代码块，如果有的话，给Baby.class类进行初始化
* 3.堆内存中开辟空间，分配内存地址
* 4.堆内存中建立对象的特有属性，并进行【默认初始化】
* 5.对属性进行【显示初始化】
* 6.对对象进行【构造代码块初始化】
* 7.对对象进行【构造函数初始化】
* 8.将内存地址付给占内存中的p变量

主函数：
```Java
public static void main(String[] args){}
```
封装：提高重用性；安全性

static关键字：
* 用于修饰类成员：修饰的成员存储在数据区，被该类的对象共享 （成员(实例)变量存储在堆内存）
* 特点：随着类的加载而加载；优先于对象存在；被本类的所有对象共享；可直接被类名调用
* 注意：静态方法只能访问静态成员，非静态方法都可以访问；不可以用this super关键字；主函数是静态的
* 使用：静态变量，共享数据；静态函数，不访问非静态数据
    
成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。
初始化时执行顺序：静态代码块 构造代码块 构造函数

final关键字：
* 修饰类：不能被继承
* 修饰方法：不能被复写
* 修饰变量：基本数据类型变量->常量，引用型变量->初始化后不能指向其他对象。

单例设计模式：
        定义私有的构造函数；创建一个私有、静态的本类对象；定义共有、静态方法方法返回该对象

## 继承
is a

关键字：extends

* 提高了代码的复用性；
* 多态特性的前提

java只支持单继承，不支持多继承（用多实现的形式代替），但是支持多重继承。

对于一个有继承关系的类体系，在使用时先查阅顶层父类的内容，创建最底层子类的对象。

特点：
* 成员变量：this super
* 成员函数：子类方法覆盖父类同名方法——重写（子类方法权限大鱼父类方法权限；要么都是静态，要么都不是静态）
* 构造函数：子类构造函数第一行都有一条隐藏语句——super()调用父类空参数构造函数。所以，子类实例化先调用父类构造函数

## 抽象类

关键字：abstract

多个类出现相同功能，但是功能主体不同，可以向上抽取，只抽取功能定义，而不抽取功能主体。

特点：
* 抽象方法只能定义在抽象类中，必须用关键字abstract修饰
* 抽象方法只定义方法声明，不定义方法实现
* 抽象类不可以实例化，因为调用抽象方法没意义
* 抽象类只有通过子类继承并覆盖所有抽象方法，该子类才可以被实例化

注意：
* 抽象类也有构造函数，初始化子类对象
* 抽象类中可以定义非抽象方法，只比一般类多了抽象方法
* 抽象关键字abstract不可以和final/private/ static共存
* 抽象类可以不定义抽象方法，为了不让该类创建对象

模板方法设计模式;
在定义功能时，一部分确定，一部分不确定，而且确定的部分调用了不确定的部分，将不确定的部分暴露出去，定义为抽象方法，由该类的子类完成

## 接口

关键字：interface

特殊的抽象类：方法都是抽象的

接口成员：全局常量、抽象方法
* 成员变量：public static final
* 成员方法：public abstract
接口不可以实例化，接口的子类必须实现了接口中所有的抽象方法后，该子类才可以创建实例。

关系:
* 类与接口关系：实现 implements
* 接口可以多实现
* 接口和接口之间可以继承

特点：
* 接口是对外提供的规则
* 接口是功能的扩展
* 接口降低了程序的耦合性

## 接口和抽象类
共性：都是不断向上抽取的结果

区别：
* 接口实现对象的扩展功能；抽象类定义一个体系的基本内容
* 接口需要被实现，可以多实现；抽象类只能被继承，只能单继承
* 接口中都是抽象方法，需要子类实现；抽象类可以有非抽象方法
* 接口使用like a关系；抽象类使用is a关系
* 接口中成员修饰符固定；抽象类成员修饰符自定义
 
## 多态 
体现：父类引用或者接口的引用指向了自己的子类对象

好处：提高程序扩展性

弊端：父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中方法，不可以访问子类特有方法

前提：必须要有关系，比如继承、实现；覆盖

多态自始至终，都是子类对象在做着变化

判断对象是哪个具体子类类型：instanceof()

多态在子父类的成员上体现的特点：
* 成员函数：在多态调用时，编译看左边，运行看右边
* 编译时期，看 引用型变量所属类是否有调用的方法，有则编译通过，否则不通过；运行时期，看对象所属类是否有调用的方法
        
        因为子父类中，同名函数有覆盖特性

* 成员变量：在多态调用时，都看左边

* 静态成员函数：在多态调用时，都看左边
        
        静态方法属于该方法所属的类，调用静态方法引用是哪个类引用，调用的就是哪个类的静态方法

## Object
所有类的直接或者间接父类，定义了所有对象都具有的功能
```java
boolean equals(Object obj)
String toString()
Class getClass()    返回任意对象运行时的所属字节码文件对象
int hashCode()    返回对象的哈希值
```

## 内部类
内部类可以直接访问外部类（Outer.this）；外部类访问内部类，必须建立内部类的实例对象。

访问格式：

1、内部类定义在局部：不可以内成员修饰符修饰；可以访问外部类的成员，不可以访问其他所在局部的变量，只能访问局部中被final修饰的局部变量。

2、内部类定义在外部类的成员位置上：可以被修饰符private、static修饰
* 格式：Outer.Inner in = new Outer.new Inner();  （很少用，一般通过外部类的方法获取）
* private：内部类在外部类中封装
* static：内部类具有static特性，只能访问外部类中金泰成员
* 在外部其他类中：访问静态内部类的静态成员Outer.Inner.fuc();
* 非静态成员new Outer.Inner.fuc();

内部类变异后的文件名为：“外部类名$内部类名.java”

### 匿名内部类

其实就是一个匿名子类对象，前提是内部类需要继承类或实现接口。

格式：new 父类名&接口名(){ 定义子类成员；覆盖父类方法；}.方法名；

使用场景：封装方法少，直接用